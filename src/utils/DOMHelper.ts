// ================================================================================================
// DOMHelper - DOM操作のヘルパークラス
// 安全で一貫性のあるDOM操作機能を提供
// ================================================================================================

/**
 * DOM操作のヘルパークラス
 * ブラウザ間の差異を吸収し、安全なDOM操作機能を提供
 */
export class DOMHelper {
    
    // ================================================================================================
    // 要素取得メソッド群
    // ================================================================================================
    
    /**
     * 要素を安全に取得
     * try-catchでエラーハンドリングを行い、不正なセレクターでもクラッシュしない
     * @param selector CSSセレクター
     * @param parent 親要素（省略時はdocument）
     * @returns 要素またはnull
     */
    static querySelector<T extends HTMLElement = HTMLElement>(\n        selector: string, \n        parent: Element | Document = document\n    ): T | null {\n        try {\n            // セレクターを使って要素を検索\n            return parent.querySelector<T>(selector);\n        } catch (error) {\n            // 不正なセレクターの場合はエラーログを出力してnullを返す\n            console.error(`Invalid selector: ${selector}`, error);\n            return null;\n        }\n    }\n\n    /**\n     * 複数の要素を安全に取得\n     * NodeListを配列に変換して扱いやすくする\n     * @param selector CSSセレクター\n     * @param parent 親要素（省略時はdocument）\n     * @returns 要素の配列\n     */\n    static querySelectorAll<T extends HTMLElement = HTMLElement>(\n        selector: string, \n        parent: Element | Document = document\n    ): T[] {\n        try {\n            // NodeListを配列に変換して返す\n            return Array.from(parent.querySelectorAll<T>(selector));\n        } catch (error) {\n            // 不正なセレクターの場合はエラーログを出力して空配列を返す\n            console.error(`Invalid selector: ${selector}`, error);\n            return [];\n        }\n    }\n\n    // ================================================================================================\n    // 値の取得・設定メソッド群\n    // ================================================================================================\n\n    /**\n     * 要素の値を取得\n     * 要素の種類に応じて適切な値を取得\n     * @param element HTML要素\n     * @returns 値\n     */\n    static getValue(element: HTMLElement): any {\n        if (element instanceof HTMLInputElement) {\n            // input要素の場合\n            if (element.type === 'checkbox' || element.type === 'radio') {\n                // チェックボックス・ラジオボタンの場合はチェック状態を返す\n                return element.checked;\n            }\n            // その他のinput要素の場合は値を返す\n            return element.value;\n        } else if (element instanceof HTMLSelectElement) {\n            // select要素の場合は選択値を返す\n            return element.value;\n        } else if (element instanceof HTMLTextAreaElement) {\n            // textarea要素の場合は入力値を返す\n            return element.value;\n        }\n        \n        // その他の要素の場合はテキストコンテンツを返す\n        return element.textContent || '';\n    }\n\n    /**\n     * 要素に値を設定\n     * 要素の種類に応じて適切な方法で値を設定\n     * @param element HTML要素\n     * @param value 設定する値\n     */\n    static setValue(element: HTMLElement, value: any): void {\n        if (element instanceof HTMLInputElement) {\n            // input要素の場合\n            if (element.type === 'checkbox' || element.type === 'radio') {\n                // チェックボックス・ラジオボタンの場合はチェック状態を設定\n                element.checked = Boolean(value);\n            } else {\n                // その他のinput要素の場合は値を文字列として設定\n                element.value = String(value);\n            }\n        } else if (element instanceof HTMLSelectElement) {\n            // select要素の場合は選択値を設定\n            element.value = String(value);\n        } else if (element instanceof HTMLTextAreaElement) {\n            // textarea要素の場合は入力値を設定\n            element.value = String(value);\n        } else {\n            // その他の要素の場合はテキストコンテンツを設定\n            element.textContent = String(value);\n        }\n    }\n\n    // ================================================================================================\n    // イベント管理メソッド群\n    // ================================================================================================\n\n    /**\n     * イベントリスナーを安全に追加\n     * 削除用の関数を返すことでメモリリークを防ぐ\n     * @param element 要素\n     * @param event イベント名\n     * @param handler ハンドラー\n     * @param options オプション\n     * @returns 削除用の関数\n     */\n    static addEventListener(\n        element: Element | Window | Document,\n        event: string,\n        handler: EventListener,\n        options?: AddEventListenerOptions\n    ): () => void {\n        // イベントリスナーを追加\n        element.addEventListener(event, handler, options);\n        \n        // リスナーを削除する関数を返す（クリーンアップ用）\n        return () => {\n            element.removeEventListener(event, handler, options);\n        };\n    }\n\n    /**\n     * 複数のイベントリスナーを追加\n     * 同一のハンドラーを複数のイベントに設定\n     * @param element 要素\n     * @param events イベント名の配列\n     * @param handler ハンドラー\n     * @param options オプション\n     * @returns 削除用の関数\n     */\n    static addEventListeners(\n        element: Element | Window | Document,\n        events: string[],\n        handler: EventListener,\n        options?: AddEventListenerOptions\n    ): () => void {\n        // 各イベントにリスナーを追加し、削除関数を保存\n        const removers = events.map(event => \n            this.addEventListener(element, event, handler, options)\n        );\n        \n        // 全てのリスナーを削除する関数を返す\n        return () => {\n            removers.forEach(remover => remover());\n        };\n    }\n\n    // ================================================================================================\n    // 要素状態チェックメソッド群\n    // ================================================================================================\n\n    /**\n     * 要素が表示されているかチェック\n     * CSSの表示状態を総合的に判定\n     * @param element 要素\n     * @returns 表示されている場合true\n     */\n    static isVisible(element: HTMLElement): boolean {\n        if (!element) return false;\n        \n        // display: none チェック\n        if (getComputedStyle(element).display === 'none') return false;\n        \n        // visibility: hidden チェック\n        if (getComputedStyle(element).visibility === 'hidden') return false;\n        \n        // opacity: 0 チェック\n        if (getComputedStyle(element).opacity === '0') return false;\n        \n        // サイズチェック（幅または高さが0の場合は非表示とみなす）\n        const rect = element.getBoundingClientRect();\n        if (rect.width === 0 || rect.height === 0) return false;\n        \n        return true;\n    }\n\n    /**\n     * 要素が無効化されているかチェック\n     * disabled属性やaria-disabled属性を確認\n     * @param element 要素\n     * @returns 無効化されている場合true\n     */\n    static isDisabled(element: HTMLElement): boolean {\n        // disabled属性を持つ要素の場合\n        if ('disabled' in element) {\n            return (element as HTMLInputElement).disabled;\n        }\n        \n        // aria-disabled属性をチェック\n        return element.getAttribute('aria-disabled') === 'true';\n    }\n\n    /**\n     * 要素をフォーカス\n     * 安全にフォーカスを設定（focus関数が存在しない場合の対応）\n     * @param element 要素\n     * @param options オプション\n     */\n    static focus(element: HTMLElement, options?: FocusOptions): void {\n        // focus関数が存在する場合のみ実行\n        if (element && typeof element.focus === 'function') {\n            element.focus(options);\n        }\n    }\n\n    // ================================================================================================\n    // DOM操作メソッド群\n    // ================================================================================================\n\n    /**\n     * 要素の最も近い親要素を取得\n     * closest関数の安全なラッパー\n     * @param element 要素\n     * @param selector セレクター\n     * @returns 親要素またはnull\n     */\n    static closest<T extends HTMLElement = HTMLElement>(\n        element: Element,\n        selector: string\n    ): T | null {\n        try {\n            // closest関数を使って最も近い親要素を検索\n            return element.closest<T>(selector);\n        } catch (error) {\n            // 不正なセレクターの場合はエラーログを出力してnullを返す\n            console.error(`Invalid selector: ${selector}`, error);\n            return null;\n        }\n    }\n\n    /**\n     * 要素が特定の要素の子孫かチェック\n     * 親子関係の確認\n     * @param parent 親要素\n     * @param element 要素\n     * @returns 子孫の場合true\n     */\n    static contains(parent: Element, element: Element): boolean {\n        return parent.contains(element);\n    }\n\n    // ================================================================================================\n    // 属性操作メソッド群\n    // ================================================================================================\n\n    /**\n     * 要素の属性を安全に取得\n     * @param element 要素\n     * @param attribute 属性名\n     * @returns 属性値またはnull\n     */\n    static getAttribute(element: Element, attribute: string): string | null {\n        return element.getAttribute(attribute);\n    }\n\n    /**\n     * 要素の属性を安全に設定\n     * @param element 要素\n     * @param attribute 属性名\n     * @param value 値\n     */\n    static setAttribute(element: Element, attribute: string, value: string): void {\n        element.setAttribute(attribute, value);\n    }\n\n    /**\n     * 要素の属性を安全に削除\n     * @param element 要素\n     * @param attribute 属性名\n     */\n    static removeAttribute(element: Element, attribute: string): void {\n        element.removeAttribute(attribute);\n    }\n\n    /**\n     * data属性を取得\n     * dataset APIを使用した安全なdata属性アクセス\n     * @param element 要素\n     * @param key キー（data-を除く）\n     * @returns 値またはundefined\n     */\n    static getDataAttribute(element: HTMLElement, key: string): string | undefined {\n        return element.dataset[key];\n    }\n\n    /**\n     * data属性を設定\n     * dataset APIを使用した安全なdata属性設定\n     * @param element 要素\n     * @param key キー（data-を除く）\n     * @param value 値\n     */\n    static setDataAttribute(element: HTMLElement, key: string, value: string): void {\n        element.dataset[key] = value;\n    }\n\n    // ================================================================================================\n    // クラス操作メソッド群\n    // ================================================================================================\n\n    /**\n     * クラスを安全に追加\n     * 複数のクラス名を一度に追加可能\n     * @param element 要素\n     * @param className クラス名（複数可）\n     */\n    static addClass(element: Element, ...className: string[]): void {\n        element.classList.add(...className);\n    }\n\n    /**\n     * クラスを安全に削除\n     * 複数のクラス名を一度に削除可能\n     * @param element 要素\n     * @param className クラス名（複数可）\n     */\n    static removeClass(element: Element, ...className: string[]): void {\n        element.classList.remove(...className);\n    }\n\n    /**\n     * クラスの有無をチェック\n     * @param element 要素\n     * @param className クラス名\n     * @returns クラスがある場合true\n     */\n    static hasClass(element: Element, className: string): boolean {\n        return element.classList.contains(className);\n    }\n\n    /**\n     * クラスをトグル\n     * @param element 要素\n     * @param className クラス名\n     * @param force 強制的に追加/削除\n     * @returns 追加された場合true\n     */\n    static toggleClass(element: Element, className: string, force?: boolean): boolean {\n        return element.classList.toggle(className, force);\n    }\n\n    // ================================================================================================\n    // 要素作成・操作メソッド群\n    // ================================================================================================\n\n    /**\n     * 要素を作成\n     * オプションで属性やコンテンツを一括設定\n     * @param tagName タグ名\n     * @param options オプション\n     * @returns 作成された要素\n     */\n    static createElement<K extends keyof HTMLElementTagNameMap>(\n        tagName: K,\n        options?: {\n            id?: string;                        // ID属性\n            className?: string;                 // class属性\n            attributes?: Record<string, string>; // その他の属性\n            text?: string;                      // テキストコンテンツ\n            html?: string;                      // HTMLコンテンツ\n        }\n    ): HTMLElementTagNameMap[K] {\n        // 要素を作成\n        const element = document.createElement(tagName);\n        \n        if (options) {\n            // IDを設定\n            if (options.id) element.id = options.id;\n            // クラス名を設定\n            if (options.className) element.className = options.className;\n            // 属性を設定\n            if (options.attributes) {\n                Object.entries(options.attributes).forEach(([key, value]) => {\n                    element.setAttribute(key, value);\n                });\n            }\n            // テキストコンテンツを設定\n            if (options.text) element.textContent = options.text;\n            // HTMLコンテンツを設定\n            if (options.html) element.innerHTML = options.html;\n        }\n        \n        return element;\n    }\n\n    /**\n     * 要素をスムーズにスクロール\n     * 現代的なスクロール機能を提供\n     * @param element 要素\n     * @param options オプション\n     */\n    static scrollIntoView(element: Element, options?: ScrollIntoViewOptions): void {\n        // デフォルトオプションでスムーズスクロール\n        element.scrollIntoView(options ?? { behavior: 'smooth', block: 'center' });\n    }\n\n    // ================================================================================================\n    // フォーム関連メソッド群\n    // ================================================================================================\n\n    /**\n     * フォームの全てのフィールドを取得\n     * フォーム内の入力可能な要素を配列で返す\n     * @param form フォーム要素\n     * @returns フィールドの配列\n     */\n    static getFormFields(form: HTMLFormElement): HTMLElement[] {\n        const fields: HTMLElement[] = [];\n        const elements = form.elements;\n        \n        // HTMLFormControlsCollectionを走査\n        for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            // 入力要素のみを配列に追加\n            if (element instanceof HTMLInputElement ||\n                element instanceof HTMLSelectElement ||\n                element instanceof HTMLTextAreaElement) {\n                fields.push(element);\n            }\n        }\n        \n        return fields;\n    }\n\n    /**\n     * チェックボックスグループの値を取得\n     * 選択されたチェックボックスの値を配列で返す\n     * @param container コンテナ要素\n     * @returns 選択された値の配列\n     */\n    static getCheckboxGroupValue(container: Element): string[] {\n        // 選択されたチェックボックスを取得\n        const checkboxes = this.querySelectorAll<HTMLInputElement>(\n            'input[type=\"checkbox\"]:checked',\n            container\n        );\n        // 値の配列を返す\n        return checkboxes.map(checkbox => checkbox.value);\n    }\n\n    /**\n     * ラジオボタングループの値を取得\n     * 選択されたラジオボタンの値を返す\n     * @param container コンテナ要素\n     * @returns 選択された値\n     */\n    static getRadioGroupValue(container: Element): string | null {\n        // 選択されたラジオボタンを取得\n        const radio = this.querySelector<HTMLInputElement>(\n            'input[type=\"radio\"]:checked',\n            container\n        );\n        // 値を返す（選択されていない場合はnull）\n        return radio ? radio.value : null;\n    }\n}\n